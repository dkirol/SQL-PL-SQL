CREATE TABLE accounts (
id_account INTEGER GENERATED BY DEFAULT AS IDENTITY,
login VARCHAR2(60),
id_password INTEGER,
id_employee INTEGER DEFAULT NULL,
id_customer INTEGER DEFAULT NULL,
CONSTRAINT pk_account PRIMARY KEY(id_account),
CONSTRAINT fk_account_password FOREIGN KEY (id_password) REFERENCES password(id_password),
CONSTRAINT fk_accounts_employees FOREIGN KEY (id_employee) REFERENCES employees(id_employee),
CONSTRAINT fk_accounts_customers FOREIGN KEY(id_customer) REFERENCES customers(id_customer)
);

CREATE TABLE password (
id_password INTEGER GENERATED BY DEFAULT AS IDENTITY,
password CHAR(64),
CONSTRAINT pk_password PRIMARY KEY(id_password)
);

CREATE TABLE mail_rst_pass (
id_mail_rst_pass INTEGER GENERATED BY DEFAULT AS IDENTITY,
id_account INTEGER,
date_reset TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
generated_code INTEGER,
succesfull BOOLEAN DEFAULT FALSE,
CONSTRAINT pk_mail_rst_pass PRIMARY KEY(id_mail_rst_pass),
CONSTRAINT fk_mail_rst_pass_accounts FOREIGN KEY (id_account) REFERENCES accounts(id_account)
);

--FUNKCJA SPRAWDZAJACA KONTO przy logowaniu
CREATE FUNCTION check_account(v_login IN VARCHAR2, v_password IN CHAR)
RETURN BOOLEAN
IS
result BOOLEAN;
v_result INTEGER;

BEGIN
SELECT COUNT(a.id_account)
INTO  v_result
FROM accounts a INNER JOIN password p
ON a.id_password = p.id_password
WHERE a.login = v_login AND p.password = v_password;

IF v_result = 1 THEN
result := TRUE;
ELSE
result := FALSE;
END IF;

RETURN result;
END check_account;

--FUNKCJA RESETUJ¥CA HASLO
CREATE FUNCTION rst_pass(v_login IN VARCHAR2, v_mail VARCHAR2)
RETURN BOOLEAN
IS
result BOOLEAN;
count_result INTEGER;
v_id_account INTEGER;
val_rand INTEGER;

BEGIN
SELECT COUNT(*)
INTO count_result
FROM account a INNER JOIN employees e
ON a.id_employee =  e.id_employee
INNER JOIN contacts c
ON e.id_employee = c.id_employee
WHERE a.login = v_login AND c.mail = v_mail;

IF count_result = 1 THEN
    SELECT id_account
    INTO v_id_account
    FROM accounts
    WHERE login = v_login;
    
    val_rand := DBMS_RANDOM.VALUE(100, 10000);
    
    INSERT INTO mail_rst_pass(id_account, generated_code) VALUES (v_id_account, val_random);
    result := TRUE;
ELSE
    result := FALSE;
END IF;

RETURN result;
END rst_pass;

CREATE TABLE employees (
id_employee INTEGER GENERATED BY DEFAULT AS IDENTITY,
first_name VARCHAR2(40),
last_name VARCHAR2(50),
pesel NUMBER(11),
department VARCHAR2(60),
id_manager INTEGER,
CONSTRAINT c_manager FOREIGN KEY(id_manager) REFERENCES employees(id_employee),
CONSTRAINT pk_employees PRIMARY KEY (id_employee)
);

/*CALL insert_employees ('Dawid', 'Kopcx', 9595959595, 'IT', 1, 'Warszawa', 'Kochanowskiego', '10', 505505505, 'dawid.k@gmail.com'); */

--PROCEDURA dodajaca pracownika
CREATE OR REPLACE PROCEDURE insert_employees (  first_name IN VARCHAR2,
                                                last_name IN VARCHAR2,
                                                v_pesel IN NUMBER,
                                                department IN VARCHAR2,
                                                id_manager IN INTEGER,
                                                city IN VARCHAR2,
                                                street IN VARCHAR,
                                                num IN CHAR,
                                                phone IN NUMBER,
                                                mail IN VARCHAR)
IS
v_id_employee INTEGER;
BEGIN
INSERT INTO employees(first_name, last_name, pesel, department, id_manager) VALUES (first_name, last_name, v_pesel, department, id_manager);
    BEGIN
    SELECT id_employee
    INTO v_id_employee
    FROM employees
    WHERE pesel = v_pesel;
    
    INSERT INTO contacts (id_employee, city, street, num, phone, mail) VALUES (v_id_employee, city, street, num, phone, mail);
    END;
END;

--WIDOK ZWRACAJACY PRACOWNIKOW
CREATE VIEW all_employees AS
SELECT *
FROM employees e INNER JOIN contacts c
ON e.id_employee = c.id_employee;

CREATE VIEW ten_employees AS
SELECT *
FROM employees e INNER JOIN contacts c
ON e.id_employee = c.id_employee
OFFSET 0 ROWS FETCH NEXT 10 ROWS ONLY;

CREATE TABLE contacts (
id_employee INTEGER,
city VARCHAR2(50) NOT NULL,
street VARCHAR2(50) NOT NULL,
num CHAR(10),
phone NUMBER(9),
mail VARCHAR2(40),
CONSTRAINT pk_contacts PRIMARY KEY (id_employee),
CONSTRAINT fk_contact_employees FOREIGN KEY(id_employee) REFERENCES employees (id_employee)
);

CREATE TABLE employment (
id_employee INTEGER,
type_of_employment VARCHAR(30),
salary NUMBER(10, 2),
start_work DATE,
finish_work DATE DEFAULT NULL,
count_free_day NUMBER(4,1),
state_student BOOLEAN DEFAULT FALSE,
CONSTRAINT pk_employment PRIMARY KEY (id_employee),
CONSTRAINT check_type_of_employment CHECK(type_of_employment IN ('Umowa Zlecenie', 'Umowa B2B', 'Umowa o Dzielo', 'Umowa o Prace')),
CONSTRAINT fk_employment_employees FOREIGN KEY (id_employee) REFERENCES employees(id_employee)
);

CREATE TABLE holiday (
id_holiday INTEGER GENERATED BY DEFAULT AS IDENTITY,
id_employee INTEGER,
count_holiday INTEGER,
type_of_holiday VARCHAR2(30),
start_holiday DATE,
end_holiday DATE,
confirmed BOOLEAN DEFAULT FALSE,
CONSTRAINT pk_holiday PRIMARY KEY(id_holiday),
CONSTRAINT fk_holiday_employees FOREIGN KEY (holiday) REFERENCES employees (employee_id),
CONSTRAINT check_type_of_holiday CHECK (type_of_holiday IN ('Urlop', 'Urlop Macierzynski', 'Chorobowe'))
);

CREATE TABLE students (
id_student INTEGER,
first_name VARCHAR2(30),
last_name VARCHAR2(30),
id_products INTEGER,
age NUMBER(2),
id_customer INTEGER,
CONSTRAINT pk_students PRIMARY KEY (id_student),
CONSTRAINT fk_students_customers FOREIGN KEY (id_customer) REFERENCES customers(id_customer),
CONSTRAINT fk_students_products FOREIGN KEY (id_products) REFERENCES products(id_products)
);

CREATE TABLE hour_in_work (
id_hour_in_work INTEGER GENERATED BY DEFAULT AS IDENTITY,
id_employee INTEGER,
date_work DATE DEFAULT CURRENT_DATE,
hour_in_work NUMBER(5,2),
start_work TIMESTAMP,
finish_work TIMESTAMP,
CONSTRAINT pk_hour_in_work PRIMARY KEY (id_hour_in_work),
CONSTRAINT fk_hour_in_work_employees FOREIGN KEY (id_employee) REFERENCES employees(id_employee)
);

CREATE TABLE task_for_employees (
id_task INTEGER GENERATED BY DEFAULT AS IDENTITY,
id_employee INTEGER,
duration NUMBER(5,2),
stage NUMBER(1),
comment VARCHAR2(500),
CONSTRAINT pk_task_for_employees PRIMARY KEY(id_task),
CONSTRAINT check_stage CHECK(stage IN (1, 2, 3, 4, 5))
);

CREATE TABLE customers (
id_customer INTEGER GENERATED BY DEFAULT AS IDENTITY,
first_name VARCHAR2(30),
last_name VARCHAR2(30),
pesel NUMBER(11),
CONSTRAINT pk_customers PRIMARY KEY (id_customer)
);

CREATE TABLE contacts_customers (
id_customer INTEGER,
city VARCHAR2(50) NOT NULL,
street VARCHAR2(50) NOT NULL,
num CHAR(10),
phone NUMBER(9),
mail VARCHAR2(40),
CONSTRAINT pk_contacts_customers PRIMARY KEY (id_customer),
CONSTRAINT fk_contacts_customers FOREIGN KEY(id_customer) REFERENCES customers(id_customer)
);

CREATE TABLE orders (
id_order INTEGER GENERATED BY DEFAULT AS IDENTITY,
id_customer INTEGER,
id_product INTEGER,
type_pay CHAR(4),
count_part_pay NUMBER(3),
order_date TIMESTAMP,
CONSTRAINT pk_orders PRIMARY KEY (id_order),
CONSTRAINT check_type_pay CHECK (type_pay IN ('full','part')),
CONSTRAINT fk_orders_customer FOREIGN KEY (id_customer) REFERENCES customers(id_customer),
CONSTRAINT fk_orders_products FOREIGN KEY (id_product) REFERENCES products (id_product)
);

CREATE TABLE part_paid (
id_part_pay INTEGER GENERATED BY DEFAULT AS IDENTITY,
id_order INTEGER,
number_of_paid INTEGER,
amount NUMBER(6,2),
end_pay_date DATE,
confirmed BOOLEAN DEFAULT FALSE,
CONSTRAINT pk_part_paid PRIMARY KEY (id_part_paid),
CONSTRAINT fk_part_paid_orders FOREIGN KEY (id_order) REFERENCES orders(id_order)
);

--Widok niezaplaconych zamowien
CREATE VIEW unpaid_order AS
SELECT o.id_order, c.first_name, c.last_name, p.product_name, pp.number_of_paid, pp.amount, pp.end_pay_date
FROM orders o INNER JOIN customers c
ON o.id_customer = c.id_customer
INNER JOIN products p
ON o.id_product = p.id_product
INNER JOIN part_paid pp
ON o.id_order = pp.id_order
WHERE pp.confirmed = FALSE AND pp.end_pay_date > (pp.end_pay_date -10);

CREATE TABLE products(
id_product INTEGER GENERATED BY DEFAULT AS IDENTITY,
product_name VARCHAR2(40),
price NUMBER(10,2),
CONSTRAINT pk_products PRIMARY KEY (id_product)
);

--TRIGGER który tworzy raty dla danego zakupu(w przypadku wziêcia raty)

CREATE OR REPLACE TRIGGER part_orders
AFTER INSERT OR UPDATE
ON orders
FOR EACH ROW

DECLARE

v_type_pay orders.type_pay%TYPE := :new.type_pay; -- typ patnoœci
v_count_part_pay orders.count_part_pay%TYPE := :new.count_part_pay; -- liczba rat wybranych
v_id_order orders.id_order%TYPE := :new.id_order; -- numer zamówienia
v_id_product orders.id_product%TYPE := :new.id_product; -- numer produktu
v_end_pay_date DATE := CURRENT_DATE; -- finalny dzien platnosci
v_amount NUMBER(6,2); -- kwota raty
v_price products.price%TYPE; -- kwota produktu

BEGIN


SELECT price
INTO v_price
FROM products
WHERE id_product = v_id_product;

IF v_type_pay = 'part' THEN
v_amount := (v_price * 1.2) / v_count_part_pay;

FOR i IN 1..v_count_part_pay
LOOP

INSERT INTO part_paid(id_order, number_of_pay, amount, end_pay_date)
VALUES (v_id_order, i, v_amount, ROUND(ADD_MONTHS(v_end_pay_date, i), 'MM') + 10);
END LOOP;

ELSIF v_type_pay = 'full' THEN

v_amount := v_price;
INSERT INTO part_paid(id_order, number_of_pay, amount, end_pay_date)
VALUES (v_id_order, 1, v_amount, ROUND(ADD_MONTHS(v_end_pay_date, 1), 'MM') + 10);
END IF;

END;

CREATE TABLE late_payment(
id_late_payment INTEGER GENERATED BY DEFAULT AS IDENTITY,
notification VARCHAR2(200),
date_send DATE DEFAULT CURRENT_DATE,
id_part_pay INTEGER INVISIBLE,
id_order INTEGER,
id_customer INTEGER,
sendto VARCHAR2(50),
number_of_paid INTEGER,
CONSTRAINT pk_late_payment PRIMARY KEY(id_late_payment),
CONSTRAINT fk_late_payment_customer FOREIGN KEY(id_customer) REFERENCES customers(id_customer),
CONSTRAINT fk_late_payment_part_paid FOREIGN KEY(id_part_pay) REFERENCES part_pay(id_part_pay)
);

--PROCEDURA z przypomnieniami co do zalegej zapaty

CREATE OR REPLACE PROCEDURE send_notification_to_pay
AS
CURSOR cursor_1 IS
    SELECT pp.id_part_pay, pp.id_order, pp.number_of_pay, pp.amount, pp.end_pay_date, o.id_customer, c.first_name, c.last_name, cc.email
    FROM part_pay pp LEFT JOIN orders o
    ON pp.id_order = o.id_order
    LEFT JOIN customers c
    ON o.id_customer = c.id_customer
    LEFT JOIN contact_customers cc
    ON c.id_customer = cc.id_customer
    WHERE end_pay_date < CURRENT_DATE AND confirmed = FALSE;
    
BEGIN

FOR i IN cursor_1
LOOP
    v_notification := ('Tresæ maila :)' || i.first_name, i.last_name, i.id_order, i.amount, i.end_pay_date || 'reszta maila, do wypelnienia') ;  
    
    INSERT INTO late_payment(notifiaction, id_part_pay, id_order, id_customer, sendto, number_of_paid)
    VALUES (v_notification, i.id_part_pay, i.id_order, i.id_customer, i.email, i.number_of_paid); 
END LOOP;

END;

/*CURSOR cursor_2 IS
    SELECT o.id_customer, c.first_name, c.last_name, cc.email
    INTO v_id_customer, v_first_name, v_last_name, v_email
    FROM orders o LEFT JOIN customers c
    ON o.id_customer = c.id_customer
    LEFT JOIN contact_customers cc
    ON c.id_customer = cc.id_customer
    WHERE id_order = v_id_order;
*/

/*DECLARE
month_some DATE := CURRENT_DATE;
BEGIN
FOR i IN 1..10
LOOP

DBMS_OUTPUT.PUT_LINE(ROUND(ADD_MONTHS(month_some, i), 'MM')+ 10);
END LOOP;
END;
*/

